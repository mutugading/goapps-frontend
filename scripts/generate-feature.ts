#!/usr/bin/env npx tsx
/**
 * Feature Generator Script
 *
 * Generates boilerplate files for new CRUD features based on UOM template.
 *
 * Usage:
 *   npx tsx scripts/generate-feature.ts --service=finance --entity=currency --name="Currency"
 *
 * Options:
 *   --service   Service scope (finance, purchase, sales, inventory, iam)
 *   --entity    Entity name in lowercase (e.g., currency, vendor, customer)
 *   --name      Display name for messages (e.g., "Currency", "Vendor")
 *   --idField   ID field name (default: {entity}Id, e.g., currencyId)
 *
 * Generated files:
 *   - src/types/{service}/{entity}.ts
 *   - src/hooks/{service}/use-{entity}.ts
 *   - src/components/{service}/{entity}/index.ts
 *   - src/components/{service}/{entity}/{entity}-form-dialog.tsx
 *   - src/components/{service}/{entity}/{entity}-table.tsx
 *   - src/components/{service}/{entity}/{entity}-filters.tsx
 *   - src/components/{service}/{entity}/{entity}-pagination.tsx
 *   - src/components/{service}/{entity}/{entity}-delete-dialog.tsx
 *   - src/app/api/v1/{service}/{entity}s/route.ts
 *   - src/app/api/v1/{service}/{entity}s/[{entity}Id]/route.ts
 */

import * as fs from "fs"
import * as path from "path"

// Parse command line arguments
function parseArgs(): {
  service: string
  entity: string
  name: string
  idField: string
} {
  const args: Record<string, string> = {}

  process.argv.slice(2).forEach((arg) => {
    const [key, value] = arg.replace(/^--/, "").split("=")
    if (key && value) {
      args[key] = value
    }
  })

  if (!args.service || !args.entity || !args.name) {
    console.error(`
Usage: npx tsx scripts/generate-feature.ts --service=<service> --entity=<entity> --name=<name>

Options:
  --service   Service scope (finance, purchase, sales, inventory, iam)
  --entity    Entity name in lowercase (e.g., currency, vendor)
  --name      Display name (e.g., "Currency", "Vendor")
  --idField   ID field name (default: {entity}Id)

Example:
  npx tsx scripts/generate-feature.ts --service=finance --entity=currency --name="Currency"
  npx tsx scripts/generate-feature.ts --service=purchase --entity=vendor --name="Vendor" --idField=vendorId
`)
    process.exit(1)
  }

  return {
    service: args.service,
    entity: args.entity.toLowerCase(),
    name: args.name,
    idField: args.idField || `${args.entity.toLowerCase()}Id`,
  }
}

// Convert to PascalCase
function toPascalCase(str: string): string {
  return str.replace(/(^|[-_])(\w)/g, (_, __, c) => c.toUpperCase())
}

// Convert to camelCase
function toCamelCase(str: string): string {
  const pascal = toPascalCase(str)
  return pascal.charAt(0).toLowerCase() + pascal.slice(1)
}

// Convert to kebab-case
function toKebabCase(str: string): string {
  return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()
}

// Ensure directory exists
function ensureDir(filePath: string): void {
  const dir = path.dirname(filePath)
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true })
  }
}

// Write file with backup
function writeFile(filePath: string, content: string): void {
  ensureDir(filePath)

  if (fs.existsSync(filePath)) {
    console.log(`  [SKIP] ${filePath} already exists`)
    return
  }

  fs.writeFileSync(filePath, content)
  console.log(`  [CREATE] ${filePath}`)
}

// Generate types file
function generateTypes(config: ReturnType<typeof parseArgs>): string {
  const { service, entity, name, idField } = config
  const Pascal = toPascalCase(entity)
  const Camel = toCamelCase(entity)

  return `// ${name} Types - Re-exports from generated proto and UI helpers
// Auto-generated by generate-feature.ts

// =============================================================================
// Re-export proto-generated types
// =============================================================================

export {
  // Entity
  type ${Pascal} as ${Pascal},

  // Requests
  type Create${Pascal}Request,
  type Update${Pascal}Request,
  type List${Pascal}sRequest,
  type Export${Pascal}sRequest,
  type Import${Pascal}sRequest,

  // Responses
  type Create${Pascal}Response,
  type Update${Pascal}Response,
  type Delete${Pascal}Response,
  type Get${Pascal}Response,
  type List${Pascal}sResponse,
  type Export${Pascal}sResponse,
  type Import${Pascal}sResponse,
  type DownloadTemplateResponse,

  // Response parsers (fromJSON)
  ${Pascal} as ${Pascal}Parser,
  Create${Pascal}Response as Create${Pascal}ResponseParser,
  Update${Pascal}Response as Update${Pascal}ResponseParser,
  Delete${Pascal}Response as Delete${Pascal}ResponseParser,
  Get${Pascal}Response as Get${Pascal}ResponseParser,
  List${Pascal}sResponse as List${Pascal}sResponseParser,
  Export${Pascal}sResponse as Export${Pascal}sResponseParser,
  Import${Pascal}sResponse as Import${Pascal}sResponseParser,
  DownloadTemplateResponse as DownloadTemplateResponseParser,

  // Enums (if any)
  // ${Pascal}Category,
  // ${Pascal}Status,
} from "@/types/generated/${service}/v1/${entity}"

// =============================================================================
// UI Display Labels
// =============================================================================

// TODO: Define category labels if entity has categories
// export const ${Pascal.toUpperCase()}_CATEGORY_LABELS: Record<number, string> = {
//   0: "Unspecified",
//   1: "Category One",
//   2: "Category Two",
// }

// TODO: Define status labels if entity has status
// export const ${Pascal.toUpperCase()}_STATUS_LABELS: Record<number, string> = {
//   0: "Inactive",
//   1: "Active",
// }

// =============================================================================
// Form Options for Select dropdowns
// =============================================================================

// TODO: Define form options
// export const ${Pascal.toUpperCase()}_CATEGORY_OPTIONS = [
//   { value: "0", label: "All Categories" },
//   { value: "1", label: "Category One" },
//   { value: "2", label: "Category Two" },
// ]

// =============================================================================
// API Params (simplified from proto)
// =============================================================================

export interface List${Pascal}sParams {
  page?: number
  pageSize?: number
  search?: string
  sortBy?: string
  sortOrder?: "asc" | "desc"
  isActive?: boolean
  // TODO: Add entity-specific filters
  // category?: number
}

export interface Export${Pascal}sParams {
  search?: string
  isActive?: boolean
  // TODO: Add entity-specific filters
}

// =============================================================================
// Form Data
// =============================================================================

export interface ${Pascal}FormData {
  ${Camel}Code: string
  ${Camel}Name: string
  description: string
  isActive: boolean
  // TODO: Add entity-specific fields
}

export const DEFAULT_${Pascal.toUpperCase()}_FORM_VALUES: ${Pascal}FormData = {
  ${Camel}Code: "",
  ${Camel}Name: "",
  description: "",
  isActive: true,
  // TODO: Add entity-specific defaults
}
`
}

// Generate hooks file
function generateHooks(config: ReturnType<typeof parseArgs>): string {
  const { service, entity, name, idField } = config
  const Pascal = toPascalCase(entity)
  const Camel = toCamelCase(entity)
  const kebab = toKebabCase(entity)

  return `"use client"

// ${name} Hooks - TanStack Query hooks for ${name} operations
// Auto-generated by generate-feature.ts

import { useMutation, useQueryClient } from "@tanstack/react-query"
import { toast } from "sonner"

import { createCrudHooks } from "@/lib/hooks"
import { apiClient, buildQueryString, downloadFileFromBytes } from "@/lib/api"
import {
  type ${Pascal},
  type Create${Pascal}Request,
  type Update${Pascal}Request,
  type List${Pascal}sParams,
  type Export${Pascal}sParams,
  type List${Pascal}sResponse,
  type Create${Pascal}Response,
  type Update${Pascal}Response,
  type Delete${Pascal}Response,
  type Get${Pascal}Response,
  type Export${Pascal}sResponse,
  type Import${Pascal}sResponse,
  type DownloadTemplateResponse,
  List${Pascal}sResponseParser,
  Create${Pascal}ResponseParser,
  Update${Pascal}ResponseParser,
  Delete${Pascal}ResponseParser,
  Get${Pascal}ResponseParser,
  Export${Pascal}sResponseParser,
  Import${Pascal}sResponseParser,
  DownloadTemplateResponseParser,
} from "@/types/${service}/${entity}"

// ============================================================================
// Create CRUD hooks using factory
// ============================================================================

const {
  useList: use${Pascal}s,
  useGet: use${Pascal},
  useCreate: useCreate${Pascal},
  useUpdate: useUpdate${Pascal},
  useDelete: useDelete${Pascal},
  queryKeys: ${Camel}Keys,
} = createCrudHooks<
  ${Pascal},
  List${Pascal}sParams,
  Create${Pascal}Request,
  Update${Pascal}Request,
  List${Pascal}sResponse,
  Create${Pascal}Response,
  Update${Pascal}Response,
  Delete${Pascal}Response,
  Get${Pascal}Response
>({
  serviceScope: "${service}",
  resourceName: "${Pascal}",
  apiBasePath: "/api/v1/${service}/${entity}s",
  parsers: {
    listResponse: (data) => List${Pascal}sResponseParser.fromJSON(data),
    createResponse: (data) => Create${Pascal}ResponseParser.fromJSON(data),
    updateResponse: (data) => Update${Pascal}ResponseParser.fromJSON(data),
    deleteResponse: (data) => Delete${Pascal}ResponseParser.fromJSON(data),
    getResponse: (data) => Get${Pascal}ResponseParser.fromJSON(data),
  },
  getEntityId: (${Camel}) => ${Camel}.${idField},
  messages: {
    createSuccess: "${name} created successfully",
    updateSuccess: "${name} updated successfully",
    deleteSuccess: "${name} deleted successfully",
  },
})

// Export CRUD hooks
export { use${Pascal}s, use${Pascal}, useCreate${Pascal}, useUpdate${Pascal}, useDelete${Pascal}, ${Camel}Keys }

// ============================================================================
// Export Hook
// ============================================================================

export function useExport${Pascal}s() {
  return useMutation({
    mutationFn: async (params: Export${Pascal}sParams = {}): Promise<Export${Pascal}sResponse> => {
      const queryString = buildQueryString(params as Record<string, unknown>)
      const rawResponse = await apiClient.get<unknown>(\`/api/v1/${service}/${entity}s/export\${queryString}\`)
      return Export${Pascal}sResponseParser.fromJSON(rawResponse)
    },
    onSuccess: (response) => {
      if (response.base?.isSuccess && response.fileContent.length > 0) {
        downloadFileFromBytes(response.fileContent, response.fileName || "${entity}s-export.xlsx")
        toast.success("Export completed successfully")
      } else {
        toast.error(response.base?.message || "Failed to export ${name}s")
      }
    },
    onError: (error: Error) => {
      toast.error(error.message || "Failed to export ${name}s")
    },
  })
}

// ============================================================================
// Import Hook
// ============================================================================

interface ImportData {
  fileContent: Uint8Array
  fileName: string
  duplicateAction: string
}

export function useImport${Pascal}s() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (data: ImportData): Promise<Import${Pascal}sResponse> => {
      const rawResponse = await apiClient.post<unknown>("/api/v1/${service}/${entity}s/import", {
        fileContent: Array.from(data.fileContent),
        fileName: data.fileName,
        duplicateAction: data.duplicateAction,
      })
      return Import${Pascal}sResponseParser.fromJSON(rawResponse)
    },
    onSuccess: (response) => {
      queryClient.invalidateQueries({ queryKey: ${Camel}Keys.lists() })
      if (response.base?.isSuccess) {
        const { successCount, updatedCount, skippedCount, failedCount } = response
        toast.success(
          \`Import completed: \${successCount} created, \${updatedCount} updated, \${skippedCount} skipped, \${failedCount} failed\`
        )
      } else {
        toast.error(response.base?.message || "Failed to import ${name}s")
      }
    },
    onError: (error: Error) => {
      toast.error(error.message || "Failed to import ${name}s")
    },
  })
}

// ============================================================================
// Download Template Hook
// ============================================================================

export function useDownloadTemplate() {
  return useMutation({
    mutationFn: async (): Promise<DownloadTemplateResponse> => {
      const rawResponse = await apiClient.get<unknown>("/api/v1/${service}/${entity}s/template")
      return DownloadTemplateResponseParser.fromJSON(rawResponse)
    },
    onSuccess: (response) => {
      if (response.base?.isSuccess && response.fileContent.length > 0) {
        downloadFileFromBytes(response.fileContent, response.fileName || "${entity}-template.xlsx")
        toast.success("Template downloaded successfully")
      } else {
        toast.error(response.base?.message || "Failed to download template")
      }
    },
    onError: (error: Error) => {
      toast.error(error.message || "Failed to download template")
    },
  })
}
`
}

// Generate API routes
function generateApiRoutes(config: ReturnType<typeof parseArgs>): {
  main: string
  single: string
  export: string
  import: string
  template: string
} {
  const { service, entity, name, idField } = config
  const SERVICE_CONST = service.toUpperCase()

  const main = `import { createProxyHandlers, SERVICES } from "@/lib/api"

const proxy = createProxyHandlers({
  service: SERVICES.${SERVICE_CONST},
  basePath: "/api/v1/${service}/${entity}s",
  resourceName: "${name.toLowerCase()}",
})

// GET /api/v1/${service}/${entity}s - List ${name}s with filters
export const GET = proxy.list()

// POST /api/v1/${service}/${entity}s - Create ${name}
export const POST = proxy.create()
`

  const single = `import { createProxyHandlers, SERVICES } from "@/lib/api"

const proxy = createProxyHandlers({
  service: SERVICES.${SERVICE_CONST},
  basePath: "/api/v1/${service}/${entity}s",
  resourceName: "${name.toLowerCase()}",
})

// GET /api/v1/${service}/${entity}s/[${idField}] - Get single ${name}
export const GET = proxy.get("${idField}")

// PUT /api/v1/${service}/${entity}s/[${idField}] - Update ${name}
export const PUT = proxy.update("${idField}")

// DELETE /api/v1/${service}/${entity}s/[${idField}] - Delete ${name}
export const DELETE = proxy.delete("${idField}")
`

  const exportRoute = `import { createProxyHandlers, SERVICES } from "@/lib/api"

const proxy = createProxyHandlers({
  service: SERVICES.${SERVICE_CONST},
  basePath: "/api/v1/${service}/${entity}s",
  resourceName: "${name.toLowerCase()}",
})

// GET /api/v1/${service}/${entity}s/export - Export ${name}s to Excel
export const GET = proxy.export()
`

  const importRoute = `import { createProxyHandlers, SERVICES } from "@/lib/api"

const proxy = createProxyHandlers({
  service: SERVICES.${SERVICE_CONST},
  basePath: "/api/v1/${service}/${entity}s",
  resourceName: "${name.toLowerCase()}",
})

// POST /api/v1/${service}/${entity}s/import - Import ${name}s from Excel
export const POST = proxy.import()
`

  const templateRoute = `import { createProxyHandlers, SERVICES } from "@/lib/api"

const proxy = createProxyHandlers({
  service: SERVICES.${SERVICE_CONST},
  basePath: "/api/v1/${service}/${entity}s",
  resourceName: "${name.toLowerCase()}",
})

// GET /api/v1/${service}/${entity}s/template - Download import template
export const GET = proxy.template()
`

  return {
    main,
    single,
    export: exportRoute,
    import: importRoute,
    template: templateRoute,
  }
}

// Generate component index
function generateComponentIndex(config: ReturnType<typeof parseArgs>): string {
  const { entity } = config
  const kebab = toKebabCase(entity)

  return `// ${toPascalCase(entity)} Components - Barrel export
// Auto-generated by generate-feature.ts

export { ${toPascalCase(entity)}FormDialog } from "./${kebab}-form-dialog"
export { ${toPascalCase(entity)}Table } from "./${kebab}-table"
export { ${toPascalCase(entity)}Filters } from "./${kebab}-filters"
export { ${toPascalCase(entity)}Pagination } from "./${kebab}-pagination"
export { ${toPascalCase(entity)}DeleteDialog } from "./${kebab}-delete-dialog"
`
}

// Generate placeholder components (user needs to fill in)
function generateComponentStubs(config: ReturnType<typeof parseArgs>): Record<string, string> {
  const { service, entity, name, idField } = config
  const Pascal = toPascalCase(entity)
  const Camel = toCamelCase(entity)
  const kebab = toKebabCase(entity)

  const formDialog = `"use client"

// ${name} Form Dialog - Create/Edit form in dialog
// Auto-generated by generate-feature.ts - Please customize for your entity

import { useState, useEffect } from "react"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { z } from "zod"
import { Loader2 } from "lucide-react"

import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Switch } from "@/components/ui/switch"
import { Textarea } from "@/components/ui/textarea"
import { useCreate${Pascal}, useUpdate${Pascal} } from "@/hooks/${service}/use-${entity}"
import { type ${Pascal}, DEFAULT_${Pascal.toUpperCase()}_FORM_VALUES } from "@/types/${service}/${entity}"

// Form validation schema - customize fields as needed
const ${Camel}FormSchema = z.object({
  ${Camel}Code: z.string().min(1, "Code is required").max(20, "Code must be at most 20 characters"),
  ${Camel}Name: z.string().min(1, "Name is required").max(100, "Name must be at most 100 characters"),
  description: z.string().max(500, "Description must be at most 500 characters"),
  isActive: z.boolean(),
  // TODO: Add entity-specific fields
})

type ${Pascal}FormValues = z.infer<typeof ${Camel}FormSchema>

interface ${Pascal}FormDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  ${Camel}?: ${Pascal} | null
}

export function ${Pascal}FormDialog({ open, onOpenChange, ${Camel} }: ${Pascal}FormDialogProps) {
  const isEditing = !!${Camel}
  const createMutation = useCreate${Pascal}()
  const updateMutation = useUpdate${Pascal}()

  const form = useForm<${Pascal}FormValues>({
    resolver: zodResolver(${Camel}FormSchema) as never,
    defaultValues: DEFAULT_${Pascal.toUpperCase()}_FORM_VALUES,
  })

  // Reset form when dialog opens/closes or ${Camel} changes
  useEffect(() => {
    if (open) {
      if (${Camel}) {
        form.reset({
          ${Camel}Code: ${Camel}.${Camel}Code || "",
          ${Camel}Name: ${Camel}.${Camel}Name || "",
          description: ${Camel}.description || "",
          isActive: ${Camel}.isActive ?? true,
        })
      } else {
        form.reset(DEFAULT_${Pascal.toUpperCase()}_FORM_VALUES)
      }
    }
  }, [open, ${Camel}, form])

  const onSubmit = async (data: ${Pascal}FormValues) => {
    try {
      if (isEditing && ${Camel}) {
        await updateMutation.mutateAsync({
          id: ${Camel}.${idField},
          data: {
            ${Camel}Code: data.${Camel}Code,
            ${Camel}Name: data.${Camel}Name,
            description: data.description,
            isActive: data.isActive,
          },
        })
      } else {
        await createMutation.mutateAsync({
          ${Camel}Code: data.${Camel}Code,
          ${Camel}Name: data.${Camel}Name,
          description: data.description,
          isActive: data.isActive,
        })
      }
      onOpenChange(false)
    } catch (error) {
      // Error handled by mutation
    }
  }

  const isPending = createMutation.isPending || updateMutation.isPending

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>{isEditing ? "Edit" : "Create"} ${name}</DialogTitle>
          <DialogDescription>
            {isEditing ? "Update the ${name.toLowerCase()} details below." : "Fill in the details to create a new ${name.toLowerCase()}."}
          </DialogDescription>
        </DialogHeader>

        <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="${Camel}Code">Code</Label>
            <Input
              id="${Camel}Code"
              {...form.register("${Camel}Code")}
              placeholder="Enter code"
              disabled={isEditing}
            />
            {form.formState.errors.${Camel}Code && (
              <p className="text-sm text-destructive">{form.formState.errors.${Camel}Code.message}</p>
            )}
          </div>

          <div className="space-y-2">
            <Label htmlFor="${Camel}Name">Name</Label>
            <Input
              id="${Camel}Name"
              {...form.register("${Camel}Name")}
              placeholder="Enter name"
            />
            {form.formState.errors.${Camel}Name && (
              <p className="text-sm text-destructive">{form.formState.errors.${Camel}Name.message}</p>
            )}
          </div>

          <div className="space-y-2">
            <Label htmlFor="description">Description</Label>
            <Textarea
              id="description"
              {...form.register("description")}
              placeholder="Enter description (optional)"
              rows={3}
            />
            {form.formState.errors.description && (
              <p className="text-sm text-destructive">{form.formState.errors.description.message}</p>
            )}
          </div>

          <div className="flex items-center space-x-2">
            <Switch
              id="isActive"
              checked={form.watch("isActive")}
              onCheckedChange={(checked) => form.setValue("isActive", checked)}
            />
            <Label htmlFor="isActive">Active</Label>
          </div>

          <DialogFooter>
            <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
              Cancel
            </Button>
            <Button type="submit" disabled={isPending}>
              {isPending && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              {isEditing ? "Update" : "Create"}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  )
}
`

  const table = `"use client"

// ${name} Table - Data table with actions
// Auto-generated by generate-feature.ts - Please customize columns as needed

import { Edit, Trash2, MoreHorizontal } from "lucide-react"

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { Button } from "@/components/ui/button"
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"
import { type ${Pascal} } from "@/types/${service}/${entity}"

interface ${Pascal}TableProps {
  data: ${Pascal}[]
  isLoading?: boolean
  onEdit: (${Camel}: ${Pascal}) => void
  onDelete: (${Camel}: ${Pascal}) => void
}

export function ${Pascal}Table({ data, isLoading, onEdit, onDelete }: ${Pascal}TableProps) {
  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-muted-foreground">Loading...</div>
      </div>
    )
  }

  if (data.length === 0) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-muted-foreground">No ${name.toLowerCase()}s found</div>
      </div>
    )
  }

  return (
    <div className="rounded-md border">
      <Table>
        <TableHeader>
          <TableRow>
            <TableHead>Code</TableHead>
            <TableHead>Name</TableHead>
            <TableHead>Description</TableHead>
            <TableHead>Status</TableHead>
            <TableHead className="w-[70px]">Actions</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {data.map((${Camel}) => (
            <TableRow key={${Camel}.${idField}}>
              <TableCell className="font-medium">{${Camel}.${Camel}Code}</TableCell>
              <TableCell>{${Camel}.${Camel}Name}</TableCell>
              <TableCell className="max-w-[200px] truncate">{${Camel}.description}</TableCell>
              <TableCell>
                <span className={\`px-2 py-1 rounded-full text-xs \${${Camel}.isActive ? "bg-green-100 text-green-800" : "bg-gray-100 text-gray-800"}\`}>
                  {${Camel}.isActive ? "Active" : "Inactive"}
                </span>
              </TableCell>
              <TableCell>
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button variant="ghost" size="icon">
                      <MoreHorizontal className="h-4 w-4" />
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="end">
                    <DropdownMenuItem onClick={() => onEdit(${Camel})}>
                      <Edit className="mr-2 h-4 w-4" />
                      Edit
                    </DropdownMenuItem>
                    <DropdownMenuItem onClick={() => onDelete(${Camel})} className="text-destructive">
                      <Trash2 className="mr-2 h-4 w-4" />
                      Delete
                    </DropdownMenuItem>
                  </DropdownMenuContent>
                </DropdownMenu>
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  )
}
`

  const filters = `"use client"

// ${name} Filters - Search and filter controls
// Auto-generated by generate-feature.ts

import { Search, Download, Upload, Plus } from "lucide-react"

import { Input } from "@/components/ui/input"
import { Button } from "@/components/ui/button"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { useExport${Pascal}s } from "@/hooks/${service}/use-${entity}"

interface ${Pascal}FiltersProps {
  search: string
  onSearchChange: (value: string) => void
  isActive?: boolean
  onIsActiveChange: (value: boolean | undefined) => void
  sortBy: string
  onSortByChange: (value: string) => void
  sortOrder: "asc" | "desc"
  onSortOrderChange: (value: "asc" | "desc") => void
  onCreateClick: () => void
  onImportClick: () => void
}

export function ${Pascal}Filters({
  search,
  onSearchChange,
  isActive,
  onIsActiveChange,
  sortBy,
  onSortByChange,
  sortOrder,
  onSortOrderChange,
  onCreateClick,
  onImportClick,
}: ${Pascal}FiltersProps) {
  const exportMutation = useExport${Pascal}s()

  const handleExport = () => {
    exportMutation.mutate({ search, isActive })
  }

  return (
    <div className="flex flex-col gap-4 md:flex-row md:items-center md:justify-between">
      <div className="flex flex-1 items-center gap-2">
        <div className="relative flex-1 max-w-sm">
          <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
          <Input
            placeholder="Search ${name.toLowerCase()}s..."
            value={search}
            onChange={(e) => onSearchChange(e.target.value)}
            className="pl-9"
          />
        </div>

        <Select
          value={isActive === undefined ? "all" : isActive ? "active" : "inactive"}
          onValueChange={(value) => {
            if (value === "all") onIsActiveChange(undefined)
            else if (value === "active") onIsActiveChange(true)
            else onIsActiveChange(false)
          }}
        >
          <SelectTrigger className="w-[130px]">
            <SelectValue placeholder="Status" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Status</SelectItem>
            <SelectItem value="active">Active</SelectItem>
            <SelectItem value="inactive">Inactive</SelectItem>
          </SelectContent>
        </Select>

        <Select value={sortBy} onValueChange={onSortByChange}>
          <SelectTrigger className="w-[130px]">
            <SelectValue placeholder="Sort by" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="code">Code</SelectItem>
            <SelectItem value="name">Name</SelectItem>
            <SelectItem value="created_at">Created</SelectItem>
          </SelectContent>
        </Select>

        <Select value={sortOrder} onValueChange={(v) => onSortOrderChange(v as "asc" | "desc")}>
          <SelectTrigger className="w-[100px]">
            <SelectValue placeholder="Order" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="asc">Asc</SelectItem>
            <SelectItem value="desc">Desc</SelectItem>
          </SelectContent>
        </Select>
      </div>

      <div className="flex items-center gap-2">
        <Button variant="outline" size="sm" onClick={handleExport} disabled={exportMutation.isPending}>
          <Download className="mr-2 h-4 w-4" />
          Export
        </Button>
        <Button variant="outline" size="sm" onClick={onImportClick}>
          <Upload className="mr-2 h-4 w-4" />
          Import
        </Button>
        <Button size="sm" onClick={onCreateClick}>
          <Plus className="mr-2 h-4 w-4" />
          Add ${name}
        </Button>
      </div>
    </div>
  )
}
`

  const pagination = `"use client"

// ${name} Pagination - Pagination controls
// Auto-generated by generate-feature.ts

import { ChevronLeft, ChevronRight } from "lucide-react"

import { Button } from "@/components/ui/button"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"

interface ${Pascal}PaginationProps {
  currentPage: number
  totalPages: number
  pageSize: number
  totalItems: number
  onPageChange: (page: number) => void
  onPageSizeChange: (size: number) => void
}

export function ${Pascal}Pagination({
  currentPage,
  totalPages,
  pageSize,
  totalItems,
  onPageChange,
  onPageSizeChange,
}: ${Pascal}PaginationProps) {
  const startItem = (currentPage - 1) * pageSize + 1
  const endItem = Math.min(currentPage * pageSize, totalItems)

  return (
    <div className="flex items-center justify-between">
      <div className="text-sm text-muted-foreground">
        Showing {startItem} to {endItem} of {totalItems} results
      </div>

      <div className="flex items-center gap-4">
        <div className="flex items-center gap-2">
          <span className="text-sm">Rows per page:</span>
          <Select value={pageSize.toString()} onValueChange={(v) => onPageSizeChange(Number(v))}>
            <SelectTrigger className="w-[70px]">
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="10">10</SelectItem>
              <SelectItem value="20">20</SelectItem>
              <SelectItem value="50">50</SelectItem>
              <SelectItem value="100">100</SelectItem>
            </SelectContent>
          </Select>
        </div>

        <div className="flex items-center gap-1">
          <Button
            variant="outline"
            size="icon"
            onClick={() => onPageChange(currentPage - 1)}
            disabled={currentPage <= 1}
          >
            <ChevronLeft className="h-4 w-4" />
          </Button>
          <span className="px-2 text-sm">
            Page {currentPage} of {totalPages}
          </span>
          <Button
            variant="outline"
            size="icon"
            onClick={() => onPageChange(currentPage + 1)}
            disabled={currentPage >= totalPages}
          >
            <ChevronRight className="h-4 w-4" />
          </Button>
        </div>
      </div>
    </div>
  )
}
`

  const deleteDialog = `"use client"

// ${name} Delete Dialog - Confirmation dialog for deletion
// Auto-generated by generate-feature.ts

import { Loader2 } from "lucide-react"

import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog"
import { useDelete${Pascal} } from "@/hooks/${service}/use-${entity}"
import { type ${Pascal} } from "@/types/${service}/${entity}"

interface ${Pascal}DeleteDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  ${Camel}: ${Pascal} | null
}

export function ${Pascal}DeleteDialog({ open, onOpenChange, ${Camel} }: ${Pascal}DeleteDialogProps) {
  const deleteMutation = useDelete${Pascal}()

  const handleDelete = async () => {
    if (!${Camel}) return

    try {
      await deleteMutation.mutateAsync(${Camel}.${idField})
      onOpenChange(false)
    } catch (error) {
      // Error handled by mutation
    }
  }

  return (
    <AlertDialog open={open} onOpenChange={onOpenChange}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Delete ${name}</AlertDialogTitle>
          <AlertDialogDescription>
            Are you sure you want to delete <strong>{${Camel}?.${Camel}Name}</strong>? This action cannot be undone.
          </AlertDialogDescription>
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel>Cancel</AlertDialogCancel>
          <AlertDialogAction onClick={handleDelete} disabled={deleteMutation.isPending}>
            {deleteMutation.isPending && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
            Delete
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  )
}
`

  return {
    [`${kebab}-form-dialog.tsx`]: formDialog,
    [`${kebab}-table.tsx`]: table,
    [`${kebab}-filters.tsx`]: filters,
    [`${kebab}-pagination.tsx`]: pagination,
    [`${kebab}-delete-dialog.tsx`]: deleteDialog,
    ["index.ts"]: generateComponentIndex(config),
  }
}

// Main function
function main() {
  console.log("\nüöÄ Feature Generator\n")

  const config = parseArgs()
  const { service, entity, idField } = config
  const kebab = toKebabCase(entity)

  console.log(`Generating feature: ${config.name}`)
  console.log(`  Service: ${service}`)
  console.log(`  Entity: ${entity}`)
  console.log(`  ID Field: ${idField}\n`)

  const basePath = path.resolve(__dirname, "..")

  // Generate types
  console.log("üìÅ Types:")
  writeFile(path.join(basePath, `src/types/${service}/${entity}.ts`), generateTypes(config))

  // Generate hooks
  console.log("\nüìÅ Hooks:")
  writeFile(path.join(basePath, `src/hooks/${service}/use-${entity}.ts`), generateHooks(config))

  // Generate API routes
  console.log("\nüìÅ API Routes:")
  const routes = generateApiRoutes(config)
  writeFile(path.join(basePath, `src/app/api/v1/${service}/${entity}s/route.ts`), routes.main)
  writeFile(path.join(basePath, `src/app/api/v1/${service}/${entity}s/[${idField}]/route.ts`), routes.single)
  writeFile(path.join(basePath, `src/app/api/v1/${service}/${entity}s/export/route.ts`), routes.export)
  writeFile(path.join(basePath, `src/app/api/v1/${service}/${entity}s/import/route.ts`), routes.import)
  writeFile(path.join(basePath, `src/app/api/v1/${service}/${entity}s/template/route.ts`), routes.template)

  // Generate components
  console.log("\nüìÅ Components:")
  const components = generateComponentStubs(config)
  Object.entries(components).forEach(([filename, content]) => {
    writeFile(path.join(basePath, `src/components/${service}/${entity}/${filename}`), content)
  })

  console.log("\n‚úÖ Feature generation complete!")
  console.log("\nüìù Next steps:")
  console.log("  1. Ensure proto types are generated in src/types/generated/${service}/v1/${entity}.ts")
  console.log("  2. Update src/types/${service}/${entity}.ts to match your proto structure")
  console.log("  3. Customize components as needed")
  console.log(`  4. Create page at src/app/(dashboard)/${service}/${entity}s/page.tsx`)
  console.log("  5. Add route to navigation menu")
  console.log("")
}

main()
